local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Services = {
    Players = game:GetService("Players"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    RunService = game:GetService("RunService"),
    Workspace = game:GetService("Workspace"),
    TweenService = game:GetService("TweenService"),
    TextChatService = game:GetService("TextChatService"),
    SoundService = game:GetService("SoundService")
}

local LocalPlayer = Services.Players.LocalPlayer
local localChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = localChar:WaitForChild("HumanoidRootPart")
local originalPositions = {}
local originalPlatformStand = {}
local bringPosition = hrp.CFrame * CFrame.new(0, 0, -1)
local lockedPlayers = {}
local GetPlayerData = Services.ReplicatedStorage:FindFirstChild("GetPlayerData", true)
local Camera = workspace.CurrentCamera

local Config = {
    defaultWalkSpeed = 16,
    defaultJumpPower = 50,
    clickSound = Instance.new("Sound")
}

Config.clickSound.SoundId = "rbxassetid://6042053626"
Config.clickSound.Volume = 1
Config.clickSound.Name = "GlobalClickSound"
Config.clickSound.Parent = Services.SoundService
_G.ClickSound = Config.clickSound

local State = {
    autoThrowEnabled = false,
    ToggleAutoReset = false,
    ToggleKillMurderer = false,
    ToggleKillAll = false,
    showRolePrediction = false,
    showMurdererChance = false,
    walkSpeedEnabled = false,
    jumpPowerEnabled = false,
    walkSpeedValue = Config.defaultWalkSpeed,
    jumpPowerValue = Config.defaultJumpPower,
    isNoclipEnabled = false,
    farmingEnabled = false,
    speedGlitchEnabled = false,
    simulateKnifeThrow = false,
    AvoidMurderer = false,
    Avoiding = false,
    StoredCFrame = nil,
    roleTable = {},
    predictionCache = {},
    lastCleanup = 0,
    modifiedParts = {},
    cachedGuns = {},
    touchingThreat = false,
    antiFlingLastPos = Vector3.zero,
    BombTeleportEnabled = false,
    isGrabGunActive = false,
    AutoAvoidEnabled = false,
    WallCheck = false,
    isWaitingToShoot = false,
    cachedTargetPart = nil,
    GunOutlineEnabled = false,
    FullCoinBag = false,
    roundActive = false,
    isTweening = false,
    farmSpeed = 29,
    originalPosition = nil,
    OutlineESPEnabled = {
        Murderer = false,
        Sheriff = false,
        Innocent = false,
        Hero = false,
    },
    LabelESPEnabled = {
        Murderer = false,
        Sheriff = false,
        Innocent = false,
        Hero = false,
    },
    TraceESPEnabled = {
        All = false,
        Murderer = false,
        Sheriff = false,
        Innocent = false,
    },
}

local Connections = {
    flingNeutralizerCon = nil,
    noclipConnection = nil,
    killAuraCon = nil,
    timerConn = nil,
    antiVoidTouchConn = nil,
    heartbeatConnection = nil,
    partConnections = {},
    BombConnection = nil,
    renderConnection = nil,
    coroutineThread = nil
}

local UI = {
    fakeBombButton = nil,
    noclipButton = nil,
    speedButton = nil,
    grabGunButton = nil,
    screenGui = nil,
    shootButton = nil,
    shootbackButton = nil,
    timerLabel = nil
}

local GameObjects = {
    antiVoidPart = nil,
    gunDrop = nil,
    ConnectedHandles = {},
    GunOutlineInstances = {},
    OutlineInstances = {},
    LabelInstances = {},
    TracerLines = {}
}

local roleColors = {
    Murderer = Color3.fromRGB(255, 0, 0),
    Hero = Color3.fromRGB(255, 255, 0),
    Sheriff = Color3.fromRGB(0, 0, 255),
    Innocent = Color3.fromRGB(0, 255, 0),
    Unknown = Color3.fromRGB(150, 150, 150),
}

local Utility = {}
function Utility.showPrankBombMessage(guiParent, text)
    local label = guiParent:FindFirstChild("FakeBombMessage")
    if not label then return end
    label.Text = text
    label.Visible = true
    task.delay(2, function()
        if label then label.Visible = false end
    end)
end

function Utility.startPrankBombCooldown(button)
    button.AutoButtonColor = false
    button.TextTransparency = 0.5

    for i = 21, 1, -1 do
        button.Text = "Wait " .. i .. "s"
        task.wait(1)
    end

    button.Text = "Fake\nPrank\nBomb"
    button.TextTransparency = 0
    button.AutoButtonColor = true
end
function Utility.getRolePlayer(role)
    for name, info in pairs(State.roleTable) do
        if info.Role == role then
            return name
        end
    end
    return "Unknown"
end

function Utility.isMurderer(player)
    local success, data = pcall(function()
        return Services.ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    
    if success and data then
        return data and data[player and player.Name or LocalPlayer.Name] == "Murderer"
    end
    return false
end

function Utility.blurtToChannel(message)
    local channel = Services.TextChatService:FindFirstChild("TextChannels")
    if channel and channel:FindFirstChild("RBXGeneral") then
        local success, err = pcall(function()
            channel.RBXGeneral:SendAsync(message)
        end)
        if not success then
            warn("Error sending message:", err)
        end
    end
end

function Utility.teleportToPlayer(target)
    local localChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local targetChar = target.Character

    if localChar and targetChar and targetChar:FindFirstChild("HumanoidRootPart") then
        local myHRP = localChar:WaitForChild("HumanoidRootPart")
        local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
        myHRP.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
    end
end

function Utility.teleportToLobby()
for _, model in ipairs(workspace:GetChildren()) do
		local spawns = model:FindFirstChild("Spawns")
		local spawn = spawns and spawns:FindFirstChild("Spawn")
		if spawn then
			local character = LocalPlayer.Character
			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			if hrp then
				hrp.CFrame = spawn.CFrame + Vector3.new(0, 5, 0)
			end
			return
		end
	end
end

function Utility.teleportToMapSpawn()
	for _, model in ipairs(workspace:GetChildren()) do
		if model.Name ~= "Lobby" then -- skip lobby
			local spawns = model:FindFirstChild("Spawns")
			local spawn = spawns and spawns:FindFirstChild("Spawn")
			if spawn then
				local character = LocalPlayer.Character
				local hrp = character and character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = spawn.CFrame + Vector3.new(0, 5, 0)
				end
				return
			end
		end
	end
end

function Utility.ensureKnifeEquipped()
    local char = LocalPlayer.Character
    if not char then return false end
    if char:FindFirstChild("Knife") then return true end
    local backpackKnife = LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild("Knife")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if backpackKnife and humanoid then
        humanoid:EquipTool(backpackKnife)
        return true
    end
    return false
end

function Utility.findNearestPlayer()
    local closest = nil
    local shortest = math.huge
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHRP then return end
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (player.Character.HumanoidRootPart.Position - myHRP.Position).Magnitude
            if dist < shortest then
                shortest = dist
                closest = player
            end
        end
    end
    return closest
end

function Utility.getPredictedPos(part)
    if not part or not part:IsA("BasePart") then
        return part and part.Position or Vector3.zero
    end

    local v = part.AssemblyLinearVelocity
    local mag = v.Magnitude
    if mag == 0 then
        return part.Position
    else
        local scaled = (v.Unit * part.Velocity.Magnitude) / 16.5
        local y = math.clamp(scaled.Y, -1.7, 2.65)
        return part.Position + Vector3.new(scaled.X, y, scaled.Z / 1.25)
    end
end
function Utility.resetCollisions()
    for part in pairs(State.modifiedParts) do
        if part and part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
    State.modifiedParts = {}
end

function Utility.setNoclip(state)
    State.isNoclipEnabled = state

    if Connections.noclipConnection then
        Connections.noclipConnection:Disconnect()
        Connections.noclipConnection = nil
    end

    if State.isNoclipEnabled then
        Connections.noclipConnection = Services.RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

function Utility.enableFlingVelocityBlock()
    if Connections.flingNeutralizerCon then return end
    
    Connections.flingNeutralizerCon = Services.RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local root = char.HumanoidRootPart
            local linear = root.AssemblyLinearVelocity.Magnitude
            local angular = root.AssemblyAngularVelocity.Magnitude

            if linear > 250 or angular > 250 then
                root.AssemblyLinearVelocity = Vector3.zero
                root.AssemblyAngularVelocity = Vector3.zero
                if State.antiFlingLastPos ~= Vector3.zero then
                    root.CFrame = CFrame.new(State.antiFlingLastPos)
                end
            else
                State.antiFlingLastPos = root.Position
            end
        end
    end)
end

function Utility.disableFlingVelocityBlock()
    if Connections.flingNeutralizerCon then
        Connections.flingNeutralizerCon:Disconnect()
        Connections.flingNeutralizerCon = nil
    end
end

function Utility.getClosestMurdererDistance()
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return math.huge end

    local minDist = math.huge
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and Utility.isMurderer(player) then
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - root.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                end
            end
        end
    end
    return minDist
end
function Utility.getFurthestGunDrop()
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local furthest = nil
    local maxDist = 0

    for _, part in ipairs(Services.Workspace:GetDescendants()) do
        if part:IsA("BasePart") and part.Name == "GunDrop" then
            local dist = (part.Position - root.Position).Magnitude
            if dist > maxDist then
                maxDist = dist
                furthest = part
            end
        end
    end

    return furthest
end
function Utility.grabGunOnce()
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if Utility.isMurderer(LocalPlayer) or Utility.getClosestMurdererDistance() <= 5 then return end

    local gunDrop = Utility.getFurthestGunDrop()
    if gunDrop then
        local original = root.CFrame
        root.CFrame = gunDrop.CFrame + Vector3.new(0, 3, 0)
        Services.RunService.Heartbeat:Wait()
        root.CFrame = original
    end
end

function Utility.SetCharacterCollision(enabled)
    local char = LocalPlayer.Character
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = enabled
        end
    end
end

function Utility.IsFromHumanoidRootPart(hit)
    local model = hit:FindFirstAncestorOfClass("Model")
    return model and model ~= LocalPlayer.Character and model:FindFirstChild("HumanoidRootPart")
end

function Utility.ConnectTouchEvents()
    local char = LocalPlayer.Character
    if not char then return end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            local conn = part.Touched:Connect(function(hit)
                if Utility.IsFromHumanoidRootPart(hit) then
                    State.touchingThreat = true
                    Utility.SetCharacterCollision(false)
                end
            end)
            table.insert(Connections.partConnections, conn)
        end
    end
end

function Utility.DisconnectTouchEvents()
    for _, conn in ipairs(Connections.partConnections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    Connections.partConnections = {}
end

function Utility.StartAntiFling()
    Utility.DisconnectTouchEvents()
    Utility.ConnectTouchEvents()

    if Connections.heartbeatConnection then Connections.heartbeatConnection:Disconnect() end

    Connections.heartbeatConnection = Services.RunService.Heartbeat:Connect(function()
        if not State.touchingThreat then
            Utility.SetCharacterCollision(true)
        end
        State.touchingThreat = false
    end)
end

function Utility.createGunOutline(gun)
    if not gun or not gun:IsA("BasePart") then return end
    if GameObjects.GunOutlineInstances[gun] then
        if GameObjects.GunOutlineInstances[gun].Adornee ~= gun then
            GameObjects.GunOutlineInstances[gun].Adornee = gun
        end
        return
    end

    local highlight = Instance.new("Highlight")
    highlight.Name = "GunOutline"
    highlight.FillTransparency = 1
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.OutlineColor = Color3.fromRGB(255, 215, 0)
    highlight.Adornee = gun
    highlight.Parent = gun

    GameObjects.GunOutlineInstances[gun] = highlight
end

function Utility.removeGunOutline(gun)
    local hl = GameObjects.GunOutlineInstances[gun]
    if hl then
        hl:Destroy()
        GameObjects.GunOutlineInstances[gun] = nil
    end
end

function Utility.clearAllGunOutlines()
    for gun, _ in pairs(GameObjects.GunOutlineInstances) do
        Utility.removeGunOutline(gun)
    end
end

function Utility.ToggleGunOutline(state)
    State.GunOutlineEnabled = state

    if state then
        for _, gun in ipairs(Services.Workspace:GetDescendants()) do
            if gun.Name == "GunDrop" and gun:IsA("BasePart") and not State.cachedGuns[gun] then
                State.cachedGuns[gun] = true
                Utility.createGunOutline(gun)
            end
        end

        if not Connections.renderConnection then
            Connections.renderConnection = Services.RunService.RenderStepped:Connect(function()
                if not State.GunOutlineEnabled then return end
            end)
        end
    else
        Utility.clearAllGunOutlines()
        State.cachedGuns = {}
        if Connections.renderConnection then
            Connections.renderConnection:Disconnect()
            Connections.renderConnection = nil
        end
    end
end

function Utility.getRole(player)
    local info = State.roleTable[player.Name]
    return info and info.Role or "Unknown"
end

function Utility.createOutline(player)
    if GameObjects.OutlineInstances[player] or not player.Character then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "OutlineESP"
    highlight.FillTransparency = 1
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = roleColors[Utility.getRole(player)] or roleColors.Unknown
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = player.Character
    highlight.Parent = player.Character
    GameObjects.OutlineInstances[player] = highlight
end

function Utility.createLabel(player)
    if GameObjects.LabelInstances[player] or not player.Character or not player.Character:FindFirstChild("Head") then return end
    local gui = Instance.new("BillboardGui")
    gui.Name = "LabelESP"
    gui.Size = UDim2.new(0, 200, 0, 20)
    gui.StudsOffset = Vector3.new(0, 2.5, 0)
    gui.AlwaysOnTop = true
    gui.Adornee = player.Character.Head
    gui.Parent = player.Character.Head

    local text = Instance.new("TextLabel")
    text.Name = "Text"
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextStrokeTransparency = 0.5
    text.Font = Enum.Font.Ubuntu
    text.TextSize = 16
    text.TextColor3 = roleColors.Unknown
    text.TextStrokeColor3 = Color3.new(0, 0, 0)
    text.Text = ""
    text.Parent = gui

    GameObjects.LabelInstances[player] = gui
end

function Utility.createTracer(player)
    if GameObjects.TracerLines[player] then return end
    local line = Drawing.new("Line")
    line.Thickness = 2
    line.Transparency = 1
    line.Visible = true
    GameObjects.TracerLines[player] = line
end

function Utility.removeESP(player)
    if GameObjects.OutlineInstances[player] then
        GameObjects.OutlineInstances[player]:Destroy()
        GameObjects.OutlineInstances[player] = nil
    end
    if GameObjects.LabelInstances[player] then
        GameObjects.LabelInstances[player]:Destroy()
        GameObjects.LabelInstances[player] = nil
    end
    if GameObjects.TracerLines[player] then
        GameObjects.TracerLines[player]:Remove()
        GameObjects.TracerLines[player] = nil
    end
end

function Utility.setupPlayer(player)
    player.CharacterAdded:Connect(function()
        task.wait(0.5)
        local role = Utility.getRole(player)
        if State.OutlineESPEnabled[role] then Utility.createOutline(player) end
        if State.LabelESPEnabled[role] then Utility.createLabel(player) end
        if State.TraceESPEnabled.All or State.TraceESPEnabled[role] then Utility.createTracer(player) end
    end)

    if player.Character then
        local role = Utility.getRole(player)
        if State.OutlineESPEnabled[role] then Utility.createOutline(player) end
        if State.LabelESPEnabled[role] then Utility.createLabel(player) end
        if State.TraceESPEnabled.All or State.TraceESPEnabled[role] then Utility.createTracer(player) end
    end
end

function Utility.setOutline(role, value)
    if State.OutlineESPEnabled[role] ~= nil then
        State.OutlineESPEnabled[role] = value
    end
end

function Utility.setLabel(role, value)
    if State.LabelESPEnabled[role] ~= nil then
        State.LabelESPEnabled[role] = value
    end
end

function Utility.setTrace(role, value)
    if State.TraceESPEnabled[role] ~= nil then
        State.TraceESPEnabled[role] = value
    end
end

function Utility.setAllOutlines(value)
    for role in pairs(State.OutlineESPEnabled) do
        State.OutlineESPEnabled[role] = value
    end
end

function Utility.setAllLabels(value)
    for role in pairs(State.LabelESPEnabled) do
        State.LabelESPEnabled[role] = value
    end
end

function Utility.setAllTracers(value)
    for role in pairs(State.TraceESPEnabled) do
        State.TraceESPEnabled[role] = value
    end
end

function Utility.getMurdererTargetPart(data)
    for name, info in pairs(data) do
        if info.Role == "Murderer" then
            local plr = Services.Players:FindFirstChild(name)
            if plr and plr.Character then
                return plr.Character:FindFirstChild("UpperTorso") or plr.Character:FindFirstChild("Torso")
            end
        end
    end
end

function Utility.shootMurderer()
    local character = LocalPlayer.Character
    if not character then return end

    -- Equip gun from backpack if needed
    local gun = LocalPlayer.Backpack:FindFirstChild("Gun")
    if gun then gun.Parent = character end

    local tool = character:FindFirstChild("Gun")
    if not tool then return end

    local remote = tool:FindFirstChild("KnifeLocal")
        and tool.KnifeLocal:FindFirstChild("CreateBeam")
        and tool.KnifeLocal.CreateBeam:FindFirstChild("RemoteFunction")
    if not remote then return end

    local targetPart = State.cachedTargetPart
    if not targetPart or not targetPart:IsA("BasePart") then return end

    local aimPos = targetPart.Position

    remote:InvokeServer(1, aimPos, "AH2")
end

function Utility.tryAutoShoot()
    if State.isWaitingToShoot then return end
    State.isWaitingToShoot = true

    task.spawn(function()
        local maxAttempts = 50
        local attempts = 0
        
        while attempts < maxAttempts do
            attempts = attempts + 1
            
            local character = LocalPlayer.Character
            if not character or not character:FindFirstChild("Humanoid") or character.Humanoid.Health <= 0 then
                break
            end

            local data
local success, result = pcall(function()
    return GetPlayerData and GetPlayerData:InvokeServer()
end)

if success and typeof(result) == "table" then
    data = result
else
    warn("❌ GetPlayerData failed or returned invalid data")
    return
end
            local myData = data and data[LocalPlayer.Name]
            if not myData or (myData.Role ~= "Sheriff" and myData.Role ~= "Hero") then 
                break 
            end

            if not State.cachedTargetPart or not State.cachedTargetPart.Parent then 
                break 
            end

            local canShoot = true
            if State.WallCheck then
                local head = character:FindFirstChild("Head")
                if head then
                    local origin = head.Position
                    local direction = (State.cachedTargetPart.Position - origin)
                    local distance = direction.Magnitude
                    
                    if distance < 500 then
                        direction = direction.Unit
                        
                        local raycastParams = RaycastParams.new()
                        local filterList = {character}
                        for _, player in ipairs(Services.Players:GetPlayers()) do
                            if player.Character then
                                table.insert(filterList, player.Character)
                            end
                        end
                        raycastParams.FilterDescendantsInstances = filterList
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        
                        local result = workspace:Raycast(origin, direction * (distance - 3), raycastParams)
                        
                        if result then
                            local hitPart = result.Instance
                            local hitSize = hitPart.Size
                            local isWall = (hitSize.X > 4 or hitSize.Y > 4 or hitSize.Z > 4) and hitPart.CanCollide
                            
                            if isWall then
                                canShoot = false
                            end
                        end
                    end
                end
            end
            
            if canShoot then
                task.wait(0.03) --dont ask why i added ts lel
                Utility.shootMurderer()
                break
            end
            
            task.wait(0.05)
        end
        
        State.isWaitingToShoot = false
    end)
end

function Utility.notifyGunDrop()
    Rayfield:Notify({
        Title = "ATTENTION!",
        Content = "GUN IS DROPPED!",
        Duration = 1.8,
        Image = 4483362458,
    })
end

function Utility.onMapAdded(map)
    if map:IsA("Model") then
        if map:FindFirstChild("GunDrop") then
            Utility.notifyGunDrop()
        end
        map.ChildAdded:Connect(function(child)
            if child.Name == "GunDrop" then
                Utility.notifyGunDrop()
            end
        end)
    end
end

function Utility.startGunDropDetection()
    Services.Workspace.ChildAdded:Connect(Utility.onMapAdded)
    for _, obj in pairs(Services.Workspace:GetChildren()) do
        Utility.onMapAdded(obj)
    end
end

function Utility.grabGunAt(part)
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if Utility.isMurderer(LocalPlayer) or Utility.getClosestMurdererDistance() <= 5 then return end

    local oldCF = root.CFrame
    root.CFrame = part.CFrame + Vector3.new(0, 3, 0)
    root.CFrame = oldCF
end
function Utility.loopGrabGun()
    while State.isGrabGunActive do
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root then break end

        if Utility.isMurderer(LocalPlayer) or Utility.getClosestMurdererDistance() <= 5 then break end

        local gunDrop = Utility.getFurthestGunDrop()
        if not gunDrop or not gunDrop:IsDescendantOf(workspace) then break end

        if root.Anchored then root.Anchored = false end

        local original = root.CFrame
        root.CFrame = gunDrop.CFrame + Vector3.new(0, 2.5, 0)

        Services.RunService.Heartbeat:Wait()

        root.CFrame = original

        task.wait()
    end
end

function Utility.onMapAddedForGrab(map)
    if not State.isGrabGunActive then return end
    if map:IsA("Model") then
        for _, descendant in ipairs(map:GetDescendants()) do
            if descendant.Name == "GunDrop" then
                Utility.grabGunAt(descendant)
            end
        end

        map.DescendantAdded:Connect(function(descendant)
            if State.isGrabGunActive and descendant.Name == "GunDrop" then
                Utility.grabGunAt(descendant)
            end
        end)
    end
end

function Utility.startAutoGrabGun()
	if Utility.isMurderer() then return end

	if Connections.gunGrabConnection then
		Connections.gunGrabConnection:Disconnect()
	end

	Connections.gunGrabConnection = Services.Workspace.DescendantAdded:Connect(function(desc)
		if State.isGrabGunActive and desc:IsA("BasePart") and desc.Name == "GunDrop" then
			task.spawn(function()
				Utility.loopGrabGun()
			end)
		end
	end)

	for _, obj in ipairs(Services.Workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj.Name == "GunDrop" then
			task.spawn(function()
				Utility.loopGrabGun()
			end)
			break
		end
	end
end
function Utility.getMurderer()
    for name, info in pairs(State.roleTable) do
        local role = typeof(info) == "table" and info.Role or nil
if role == "Murderer" then
            return Services.Players:FindFirstChild(name)
        end
    end
end

function Utility.teleportBack()
    local character = LocalPlayer.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp and State.StoredCFrame then
        hrp.CFrame = State.StoredCFrame
        State.StoredCFrame = nil
    end
end

function Utility.startAutoAvoid()
	task.spawn(function()
		while State.AvoidMurderer do
    if State.isWaitingToShoot then
        task.wait(0.1)
        continue
    end
			local murdererName = Utility.getRolePlayer("Murderer")
			local murderer = Services.Players:FindFirstChild(murdererName)
			local char = LocalPlayer.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local mhrp = murderer and murderer.Character and murderer.Character:FindFirstChild("HumanoidRootPart")

			if hrp and mhrp then
				local distance = (hrp.Position - mhrp.Position).Magnitude
				if distance < 12 then
					if not State.Avoiding then
						State.StoredCFrame = hrp.CFrame
						State.Avoiding = true

						Utility.teleportToLobby()

						repeat
							task.wait(0.5)
							murdererName = Utility.getRolePlayer("Murderer")
							murderer = Services.Players:FindFirstChild(murdererName)
							mhrp = murderer and murderer.Character and murderer.Character:FindFirstChild("HumanoidRootPart")
						until not State.AvoidMurderer or not mhrp or (hrp.Position - mhrp.Position).Magnitude >= 16

						if State.AvoidMurderer and State.StoredCFrame then
							hrp.CFrame = State.StoredCFrame
						end

						State.Avoiding = false
					end
				end
			end

			task.wait(0.1)
		end
	end)
end

function Utility.toggleRoundTimerESP(enabled)
    local parentGui = (gethui and gethui()) or LocalPlayer:WaitForChild("PlayerGui")

    if enabled then
        if not UI.timerScreen then
            local roundTimerPart = workspace:FindFirstChild("RoundTimerPart")
            if not roundTimerPart then return end

            local surfaceGui = roundTimerPart:FindFirstChild("SurfaceGui")
            local timerLabelInWorld = surfaceGui and surfaceGui:FindFirstChild("Timer")
            if not timerLabelInWorld then return end

            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "ballsackonly :skull:"
            screenGui.ResetOnSpawn = false
            screenGui.IgnoreGuiInset = true
            screenGui.Parent = parentGui
            UI.timerScreen = screenGui

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0.3, 0, 0.05, 0)
            label.Position = UDim2.new(0.15, 0, 0.10, 0)
            label.BackgroundTransparency = 1
            label.TextColor3 = Color3.new(1, 1, 1)
            label.Font = Enum.Font.Jura
            label.TextScaled = true
            label.Text = "Waiting for round..."
            label.Parent = screenGui
            UI.timerLabel = label

            if Connections.timerConn then Connections.timerConn:Disconnect() end
            Connections.timerConn = Services.RunService.RenderStepped:Connect(function()
                UI.timerLabel.Text = timerLabelInWorld.Text
            end)
        end
    else
        if Connections.timerConn then
            Connections.timerConn:Disconnect()
            Connections.timerConn = nil
        end
        if UI.timerScreen then
            UI.timerScreen:Destroy()
            UI.timerScreen = nil
            UI.timerLabel = nil
        end
    end
end
function Utility.TeleportAbove(part)
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local topPosition = part.Position + Vector3.new(0, part.Size.Y / 2 + 3, 0)
        character.HumanoidRootPart.CFrame = CFrame.new(topPosition)
    end
end

function Utility.HandleFound(part)
    if GameObjects.ConnectedHandles[part] then return end

    task.defer(function()
        if part and part.Parent then
            Utility.TeleportAbove(part)
        end
    end)

    local connection
    connection = part.Destroying:Connect(function()
        if GameObjects.ConnectedHandles[part] then
            GameObjects.ConnectedHandles[part]:Disconnect()
            GameObjects.ConnectedHandles[part] = nil
        end
    end)

    GameObjects.ConnectedHandles[part] = connection
end

function Utility.getNearestTarget(container, root)
    local closest, dist = nil, math.huge
    for _, item in ipairs(container:GetChildren()) do
        if item:IsA("BasePart") and item:FindFirstChild("TouchInterest") then
            local visual = item:FindFirstChild("CoinVisual")
            local isCoin = visual and visual:FindFirstChild("2Part") ~= nil
            local isEgg = visual and not isCoin
            if (not State.FullCoinBag and isCoin) or (not State.FullEggBag and isEgg) then
                local d = (root.Position - item.Position).Magnitude
                if d < dist then
                    dist = d
                    closest = item
                end
            end
        end
    end
    return closest, dist
end
function Utility.setSafeMode(enabled)
    local char = LocalPlayer.Character
    if not char then return end

    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = not enabled
        end
    end
end
function Utility.isDone()
    return State.FullCoinBag
end

function Utility.resetCharacterEffects()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.Anchored = false
        hrp.Velocity = Vector3.zero
        hrp.RotVelocity = Vector3.zero
    end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
            part.Velocity = Vector3.zero
            part.RotVelocity = Vector3.zero
        end
    end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
end

function Utility.stopAll()
    if not State.roundActive then return end
    State.roundActive = false
    State.isTweening = false
    Utility.resetCharacterEffects()

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp and State.originalPosition then
        hrp.CFrame = CFrame.new(State.originalPosition)
    end
end

function Utility.updateFlatPose()
    if not State.roundActive then return end
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if char and hrp then
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.Physics)
        end
        if State.lockedCFrame and not State.isTweening then
            hrp.CFrame = State.lockedCFrame
        end
    end
end
Services.RunService.Stepped:Connect(Utility.updateFlatPose)

function Utility.farmLoop()
	coroutine.wrap(function()
		while task.wait(0.13) do
			if not State.roundActive or Utility.isDone() then
				if Utility.isDone() then
					local roleData
					if typeof(GetPlayerData) == "Instance" and GetPlayerData:IsA("RemoteFunction") then
						local success, data = pcall(function()
							return GetPlayerData:InvokeServer()
						end)
						if success then
							roleData = data
						end
					end

					local info = roleData and roleData[LocalPlayer.Name]
					local role = info and info.Role or "Unknown"

					if role == "Innocent" and State.ToggleAutoReset then
						Utility.resetCharacterEffects()
						local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
						if hum then hum.Health = 0 end
					end

					if (role == "Sheriff" or role == "Hero") and State.ToggleKillMurderer then
						coroutine.wrap(function()
							while State.roundActive do
								local target = Utility.getMurderer()
								if not target then break end

								Handlers.handleShootMurdererTeleportBack()
								Utility.TeleportToLobby()
								task.wait(2.508)
							end
						end)()
					end

					if role == "Murderer" and State.ToggleKillAll then
						for _, plr in pairs(Services.Players:GetPlayers()) do
							if plr ~= LocalPlayer then
								Utility.bringAndStab(plr)
								task.wait(0.01)
							end
						end
					end

					if State.ToggleAutoReset then
						Utility.resetCharacterEffects()
						local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
						if hum then hum.Health = 0 end
					end

					Utility.stopAll()
				end
				continue
			end

			local char = LocalPlayer.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			if not (char and hrp) then continue end

			local container = workspace:FindFirstChild("CoinContainer", true)
			if not container then continue end

			local target = Utility.getNearestTarget(container, hrp)
			if target then
				local base = target.Position
				local under = base - Vector3.new(0, 1.6, 0)
				local flatCF = CFrame.new(under) * CFrame.Angles(math.rad(90), 0, 0)

				State.isTweening = true

				local tween = Services.TweenService:Create(
					hrp,
					TweenInfo.new((hrp.Position - under).Magnitude / State.farmSpeed, Enum.EasingStyle.Linear),
					{CFrame = flatCF}
				)
				tween:Play()

				local canceled = false
				while tween.PlaybackState == Enum.PlaybackState.Playing do
					if not State.roundActive or Utility.isDone() or not target:IsDescendantOf(workspace) then
						canceled = true
						tween:Cancel()
						break
					end
					task.wait()
				end

				State.isTweening = false
			end
		end
	end)()
end

function Utility.onRoundStart()
    if not State.farmingEnabled then return end
    State.roundActive = true
    State.FullCoinBag = false
    State.lockedCFrame = nil
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        State.originalPosition = char.HumanoidRootPart.Position
    end
end

function Utility.onRoundEnd()
    if State.farmingEnabled then
        Utility.stopAll()
    end
end

function Utility.onCoinCollected(coinType, current, max)
    local isCoinFull = tostring(coinType) == "Coin" and tonumber(current) == tonumber(max)
    if isCoinFull then
        State.FullCoinBag = true
    end
end

function Utility.startFarmLogic()
    if Connections.coroutineThread and coroutine.status(Connections.coroutineThread) == "suspended" then
        coroutine.resume(Connections.coroutineThread)
    else
        Connections.coroutineThread = coroutine.create(Utility.farmLoop)
        coroutine.resume(Connections.coroutineThread)
    end
end

function Utility.stopFarmLogic()
    Utility.stopAll()
end

function Utility.notifyRole(playerName, role)
    local imageId
    if role == "Murderer" then
        imageId = 4483362458
    elseif role == "Sheriff" then
        imageId = 4483362458
    else
        return
    end

    Rayfield:Notify({
        Title = role .. "!",
        Content = playerName .. " is the " .. role .. "!",
        Duration = 2,
        Image = imageId,
    })
end

function Utility.scanPlayers()
    if not GetPlayerData then return end

    local success, data = pcall(function()
        return GetPlayerData:InvokeServer()
    end)

    if success and data then
        for playerName, info in pairs(data) do
            local role = info.Role
            if role == "Murderer" or role == "Sheriff" then
                if not State.checkedPlayers then State.checkedPlayers = {} end
                if not State.checkedPlayers[playerName] then
                    State.checkedPlayers[playerName] = true
                    Utility.notifyRole(playerName, role)
                end
            end
        end
    end
end

function Utility.notifyPlayers()
    if not GetPlayerData then return end

    local success, data = pcall(function()
        return GetPlayerData:InvokeServer()
    end)

    if success and data then
        for playerName, info in pairs(data) do
            local role = info.Role
            if role == "Murderer" or role == "Sheriff" then
                Utility.notifyRole(playerName, role)
            end
        end
    end
end

function Utility.blurtOnlyMurderer()
    local role = Utility.getRolePlayer("Murderer")
    if role then
        Utility.blurtToChannel("Murderer = " .. role)
    else
        warn("getRolePlayer('Murderer') returned nil")
    end
end

function Utility.blurtOnlySheriff()
    local sheriff = Utility.getRolePlayer("Sheriff")
    if sheriff and sheriff ~= "" then
        Utility.blurtToChannel("Sheriff = " .. sheriff)
    else
        local hero = Utility.getRolePlayer("Hero")
        Utility.blurtToChannel("Hero = " .. (hero or "N/A"))
    end
end

function Utility.blurtBothRoles()
    Utility.blurtToChannel("Murderer = " .. Utility.getRolePlayer("Murderer"))
    local sheriff = Utility.getRolePlayer("Sheriff")
    if sheriff and sheriff ~= "" then
        Utility.blurtToChannel("Sheriff = " .. sheriff)
    else
        local hero = Utility.getRolePlayer("Hero")
        Utility.blurtToChannel("Hero = " .. (hero or "N/A"))
    end
    Utility.blurtToChannel("Makal Hub")
end
function Utility.setupESPForPlayer(player)
    local role = Utility.getRole(player) or "Unknown"

    local showOutline = role == "Unknown" and (
        State.OutlineESPEnabled.Murderer or
        State.OutlineESPEnabled.Sheriff or
        State.OutlineESPEnabled.Innocent or
        State.OutlineESPEnabled.Hero
    ) or State.OutlineESPEnabled[role]

    local showLabel = role == "Unknown" and (
        State.LabelESPEnabled.Murderer or
        State.LabelESPEnabled.Sheriff or
        State.LabelESPEnabled.Innocent or
        State.LabelESPEnabled.Hero
    ) or State.LabelESPEnabled[role]

    local showTracer = State.TraceESPEnabled.All or State.TraceESPEnabled[role] or (
        role == "Unknown" and (
            State.TraceESPEnabled.Murderer or
            State.TraceESPEnabled.Sheriff or
            State.TraceESPEnabled.Innocent or
            State.TraceESPEnabled.Hero
        )
    )

    if showOutline and not GameObjects.OutlineInstances[player] then
        Utility.createOutline(player)
    end

    if showLabel and not GameObjects.LabelInstances[player] then
        Utility.createLabel(player)
    end

    if showTracer and not GameObjects.TracerLines[player] then
        Utility.createTracer(player)
    end
end
function Utility.refreshAllESPs()
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer then
            Utility.setupESPForPlayer(player)
        end
    end
end
local Handlers = {}

function Handlers.handleGrabGunClick()
    if _G.ClickSound and typeof(_G.ClickSound) == "Instance" then
        _G.ClickSound:Play()
    end

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local getData = Services.ReplicatedStorage:FindFirstChild("GetPlayerData", true)
    local data = getData and getData:InvokeServer()
    if not data or data[LocalPlayer.Name] == "Murderer" then return end

    if GameObjects.gunDrop and GameObjects.gunDrop.Parent then
        local originalCF = hrp.CFrame
        hrp.CFrame = GameObjects.gunDrop.CFrame + Vector3.new(0, 2, 0)
        Services.RunService.Heartbeat:Wait()
        hrp.CFrame = originalCF
    end
end

function Handlers.handleShootMurderer()
    local success, data = pcall(function()
        return GetPlayerData:InvokeServer()
    end)
    if not success or typeof(data) ~= "table" then return end

    local murderer, targetPart = Utility.getMurderer()
    if not murderer or not targetPart then return end

    local gun = LocalPlayer.Backpack:FindFirstChild("Gun")
    if gun then gun.Parent = LocalPlayer.Character end

    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Gun")
    local remote = tool and tool:FindFirstChild("KnifeLocal") and tool.KnifeLocal:FindFirstChild("CreateBeam") and tool.KnifeLocal.CreateBeam:FindFirstChild("RemoteFunction")
    if not remote then return end

    remote:InvokeServer(1, Utility.getPredictedPos(targetPart), "AH2")
end

function Handlers.handleSpeedButtonClick()
    if _G.ClickSound and typeof(_G.ClickSound) == "Instance" then
        _G.ClickSound:Play()
    end

    State.speedGlitchEnabled = not State.speedGlitchEnabled

    if UI.speedButton and UI.speedButton:IsA("TextButton") then
        UI.speedButton.Text = "Speed\nGlitch"
    end

    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum and not State.speedGlitchEnabled then
        hum.WalkSpeed = 16
    end
end

function Handlers.handleNoclipButtonClick()
    if _G.ClickSound and typeof(_G.ClickSound) == "Instance" then
        _G.ClickSound:Play()
    end
    Utility.setNoclip(not State.isNoclipEnabled)
end

function Handlers.onCharacterAddedForNoclip()
    Utility.resetCollisions()
    if State.isNoclipEnabled then
        task.wait(0.1)
        Utility.setNoclip(true)
    end
end
function Handlers.handleShootMurdererTeleportBack()
    local murderer = Utility.getMurderer()
    if not murderer or not murderer.Character then return end

    local localChar = LocalPlayer.Character
    if not localChar then return end

    local localHumanoid = localChar:FindFirstChildOfClass("Humanoid")
    local localHRP = localChar:FindFirstChild("HumanoidRootPart")
    if not localHumanoid or not localHRP then return end

    local gunTool = nil
    local gunWasInBackpack = false

    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool.Name == "Gun" and tool:IsA("Tool") then
            tool.Parent = localChar
            gunTool = tool
            gunWasInBackpack = true
            break
        end
    end

    if not gunTool then
        for _, tool in pairs(localChar:GetChildren()) do
            if tool.Name == "Gun" and tool:IsA("Tool") then
                gunTool = tool
                break
            end
        end
    end

    if not gunTool then return end

    local oldAutoAvoidState = State.ToggleAutoAvoid
    State.ToggleAutoAvoid = false

    local originalCFrame = localHRP.CFrame
    State.isShootingMurderer = true

    local moveConn = Services.RunService.Heartbeat:Connect(function()
        if not murderer.Character or not murderer.Character:FindFirstChild("HumanoidRootPart") then return end
        local murderHRP = murderer.Character.HumanoidRootPart
        local targetCFrame = murderHRP.CFrame * CFrame.new(0, 0, 5)
        localHRP.CFrame = targetCFrame
    end)

    task.wait(0.2)

    local shootConn = Services.RunService.Heartbeat:Connect(function()
        if not gunTool or not gunTool:FindFirstChild("KnifeServer") or not gunTool.KnifeServer:FindFirstChild("ShootGun") then return end
        if not murderer.Character then return end
        local murderHRP = murderer.Character:FindFirstChild("HumanoidRootPart")
        local murderHum = murderer.Character:FindFirstChildOfClass("Humanoid")
        if not murderHRP or not murderHum then return end

        local remote = gunTool:FindFirstChild("KnifeLocal")
    and gunTool.KnifeLocal:FindFirstChild("CreateBeam")
    and gunTool.KnifeLocal.CreateBeam:FindFirstChild("RemoteFunction")

if remote and remote:IsA("RemoteFunction") then
    local predictedPos = murderHRP.Position + (murderHum.MoveDirection * murderHum.WalkSpeed) / 16
    remote:InvokeServer(1, predictedPos, "AH2")
 end
end)
    task.wait(0.01)

    moveConn:Disconnect()
    shootConn:Disconnect()

    localHRP.CFrame = originalCFrame

    if gunWasInBackpack and gunTool then
        gunTool.Parent = LocalPlayer.Backpack
    end

    State.isShootingMurderer = false

    State.ToggleAutoAvoid = oldAutoAvoidState
end

function Handlers.CheckForGun(callback)
    if typeof(callback) ~= "function" then
        warn("❌ CheckForGun expected a function but got:", typeof(callback))
        return
    end

    local success, err = pcall(function()
        for _, player in pairs(Services.Players:GetPlayers()) do
            local backpack = player:FindFirstChild("Backpack") or player.Backpack
            local character = player.Character

            if (backpack and backpack:FindFirstChild("Gun")) or (character and character:FindFirstChild("Gun")) then
                callback(player)
            end
        end
    end)

    if not success then
        warn("CheckForGun failed:", err)
    end
end

function Handlers.CheckForKnife(callback)
    for _, player in pairs(Services.Players:GetPlayers()) do
        local character = player.Character
        local backpack = player:FindFirstChild("Backpack")

        local knifeEquipped = character and character:FindFirstChild("Knife")
        local knifeInBackpack = backpack and backpack:FindFirstChild("Knife")

        if (knifeEquipped or knifeInBackpack) then
            callback(player)
        end
    end
end

function Handlers.onPlayerHasGun(player)
    Utility.teleportToPlayer(player)
end

function Handlers.onPlayerHasKnife(player)
    Utility.teleportToPlayer(player)
end

function Handlers.handleHumanoidStates(humanoid)
    humanoid.StateChanged:Connect(function(_, state)
        if not State.speedGlitchEnabled then return end
        if state == Enum.HumanoidStateType.Jumping then
            humanoid.WalkSpeed = 30
        elseif state == Enum.HumanoidStateType.Landed then
            humanoid.WalkSpeed = 16
        end
    end)
end

function Handlers.setupCharacter(char)
    local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
    Handlers.handleHumanoidStates(hum)
end

local UICreator = {}
function UICreator.createFakeBombButton()
    if UI.fakeBombButton then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FakeBombGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true

    pcall(function()
        screenGui.Parent = gethui and gethui() or LocalPlayer:WaitForChild("PlayerGui")
    end)

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 45, 0, 45)
    button.Position = UDim2.new(0.5, -35, 0.9, 0)
    button.Text = "Fake\nPrank\nBomb"
    button.BackgroundTransparency = 1
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Font = Enum.Font.Montserrat
    button.TextSize = 12
    button.TextWrapped = true
    button.Draggable = true
    button.Active = true
    button.Parent = screenGui
    UI.fakeBombButton = button

    Instance.new("UICorner", button).CornerRadius = UDim.new(1, 0)
    local stroke = Instance.new("UIStroke", button)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local messageLabel = Instance.new("TextLabel")
    messageLabel.Name = "FakeBombMessage"
    messageLabel.Size = UDim2.new(0, 160, 0, 25)
    messageLabel.Position = UDim2.new(0.5, -80, 0.82, -40)
    messageLabel.BackgroundColor3 = Color3.fromRGB(30, 0, 0)
    messageLabel.BackgroundTransparency = 0.3
    messageLabel.TextColor3 = Color3.fromRGB(255, 102, 102)
    messageLabel.Font = Enum.Font.Montserrat
    messageLabel.TextScaled = true
    messageLabel.TextWrapped = true
    messageLabel.Visible = false
    messageLabel.Parent = screenGui
    Instance.new("UICorner", messageLabel).CornerRadius = UDim.new(0.3, 0)

    local cooldown = false
    button.MouseButton1Click:Connect(function()
        if _G.ClickSound then _G.ClickSound:Play() end
        if cooldown then return end

        local fakeBomb = LocalPlayer.Backpack:FindFirstChild("FakeBomb") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("FakeBomb"))
        if not fakeBomb then
            Utility.showPrankBombMessage(screenGui, "Equip FakeBomb first!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local root = character:FindFirstChild("HumanoidRootPart")
        local fire = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("Misc")
        if not (humanoid and root and fire and fire:FindFirstChild("PlayEmote")) then return end

        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        task.wait(0.1)
        fire.PlayEmote:Fire("FakeBomb")
        task.wait(0.1)

        local bombTool = character:FindFirstChild("FakeBomb")
        if bombTool and bombTool:FindFirstChild("Remote") then
            local pos = root.CFrame * CFrame.new(0, -3.2, 0)
            bombTool.Remote:FireServer(pos, 50)
        end

        task.delay(0.05, function()
            local bombInstance = workspace:FindFirstChild("FakeBomb")
            if bombInstance then
                bombInstance.Touched:Connect(function(hit)
                    if hit:IsDescendantOf(character) then
                        Utility.showPrankBombMessage(screenGui, "Kena bomb sendiri!")
                    end
                end)
            end
        end)

        task.wait(0.05)
        humanoid:UnequipTools()
        cooldown = true
        Utility.startPrankBombCooldown(button)
        cooldown = false
    end)
end

function UICreator.destroyFakeBombButton()
    if UI.fakeBombButton then
        local parent = UI.fakeBombButton.Parent
        if parent then parent:Destroy() end
        UI.fakeBombButton = nil
    end
end

function UICreator.createNoclipButton()
    if UI.noclipButton then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MakalHubNoclipGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true

    local success, result = pcall(gethui)
    local parentGui

    if success and typeof(result) == "Instance" and result:IsA("ScreenGui") then
        parentGui = result
    else
        parentGui = LocalPlayer:WaitForChild("PlayerGui")
    end

    screenGui.Parent = parentGui

    UI.noclipButton = Instance.new("TextButton")
    UI.noclipButton.Size = UDim2.new(0, 40, 0, 40)
    UI.noclipButton.Position = UDim2.new(0.5, -85, 0.9, 0)
    UI.noclipButton.Text = "Noclip"
    UI.noclipButton.BackgroundTransparency = 1
    UI.noclipButton.TextColor3 = Color3.new(1, 1, 1)
    UI.noclipButton.Font = Enum.Font.Montserrat
    UI.noclipButton.TextSize = 12
    UI.noclipButton.TextWrapped = true
    UI.noclipButton.Draggable = true
    UI.noclipButton.Active = true
    UI.noclipButton.Parent = screenGui

    local corner = Instance.new("UICorner", UI.noclipButton)
    corner.CornerRadius = UDim.new(1, 0)

    local stroke = Instance.new("UIStroke", UI.noclipButton)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    UI.noclipButton.MouseButton1Click:Connect(Handlers.handleNoclipButtonClick)
    LocalPlayer.CharacterAdded:Connect(Handlers.onCharacterAddedForNoclip)
end

function UICreator.createGrabGunButton()
    if UI.grabGunButton then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MakalHubGrabGunGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    pcall(function()
        screenGui.Parent = gethui() or LocalPlayer:WaitForChild("PlayerGui")
    end)

    UI.grabGunButton = Instance.new("TextButton")
    UI.grabGunButton.Size = UDim2.new(0, 40, 0, 40)
    UI.grabGunButton.Position = UDim2.new(0.5, -35, 0.9, 0)
    UI.grabGunButton.Text = "Grab\nGun"
    UI.grabGunButton.BackgroundTransparency = 1
    UI.grabGunButton.TextColor3 = Color3.new(1, 1, 1)
    UI.grabGunButton.Font = Enum.Font.Montserrat
    UI.grabGunButton.TextSize = 12
    UI.grabGunButton.TextWrapped = true
    UI.grabGunButton.Draggable = true
    UI.grabGunButton.Active = true
    UI.grabGunButton.Parent = screenGui

    local corner = Instance.new("UICorner", UI.grabGunButton)
    corner.CornerRadius = UDim.new(1, 0)

    local stroke = Instance.new("UIStroke", UI.grabGunButton)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    UI.grabGunButton.MouseButton1Click:Connect(Handlers.handleGrabGunClick)
end

function UICreator.createSpeedButton()
    if UI.speedButton then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MakalHubSpeedGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    pcall(function()
        screenGui.Parent = gethui and gethui() or LocalPlayer:WaitForChild("PlayerGui")
    end)

    UI.speedButton = Instance.new("TextButton")
    UI.speedButton.Size = UDim2.new(0, 40, 0, 40)
    UI.speedButton.Position = UDim2.new(0.5, -35, 0.82, 0)
    UI.speedButton.Text = "Speed\nGlitch"
    UI.speedButton.BackgroundTransparency = 1
    UI.speedButton.TextColor3 = Color3.new(1, 1, 1)
    UI.speedButton.Font = Enum.Font.Montserrat
    UI.speedButton.TextSize = 12
    UI.speedButton.TextWrapped = true
    UI.speedButton.Draggable = true
    UI.speedButton.Active = true
    UI.speedButton.Parent = screenGui

    local corner = Instance.new("UICorner", UI.speedButton)
    corner.CornerRadius = UDim.new(1, 0)

    local stroke = Instance.new("UIStroke", UI.speedButton)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    UI.speedButton.MouseButton1Click:Connect(Handlers.handleSpeedButtonClick)
end
function UICreator.createShootback()
    if UI.shootbackButton then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MakalHubShootBackGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = gethui and gethui() or game:GetService("CoreGui") -- ✅ PARENT TO CORE GUI

    UI.shootbackButton = Instance.new("TextButton")
    UI.shootbackButton.Size = UDim2.new(0, 40, 0, 40)
    UI.shootbackButton.Position = UDim2.new(0.5, 10, 0.9, 0)
    UI.shootbackButton.Text = "Kill\nMurderer"
    UI.shootbackButton.BackgroundTransparency = 1
    UI.shootbackButton.TextColor3 = Color3.new(1, 1, 1)
    UI.shootbackButton.Font = Enum.Font.Montserrat
    UI.shootbackButton.TextSize = 12
    UI.shootbackButton.TextWrapped = true
    UI.shootbackButton.Draggable = true
    UI.shootbackButton.Active = true
    UI.shootbackButton.Parent = screenGui

    local corner = Instance.new("UICorner", UI.shootbackButton)
    corner.CornerRadius = UDim.new(1, 0)

    local stroke = Instance.new("UIStroke", UI.shootbackButton)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    UI.shootbackButton.MouseButton1Click:Connect(function()
        if _G.ClickSound then _G.ClickSound:Play() end
        Handlers.handleShootMurdererTeleportBack()
    end)
end
function UICreator.destroyShootbackButton()
    if UI.shootbackButton then
        local parent = UI.shootbackButton.Parent
        if parent and parent:IsA("Instance") then
            UI.shootbackButton:Destroy()
        end
        UI.shootbackButton = nil
    end
end
function UICreator.createShootButton()
    local parent = gethui and gethui() or game:GetService("CoreGui")
    if UI.screenGui then UI.screenGui:Destroy() end

    UI.screenGui = Instance.new("ScreenGui")
    UI.screenGui.Name = "MakalHubGui"
    UI.screenGui.ResetOnSpawn = false
    UI.screenGui.IgnoreGuiInset = true
    UI.screenGui.Parent = parent

    UI.shootButton = Instance.new("TextButton")
    UI.shootButton.Size = UDim2.new(0, 200, 0, 85)
    UI.shootButton.Position = UDim2.new(0.5, -100, 0.8, 0)
    UI.shootButton.Text = "Shoot Murderer"
    UI.shootButton.BackgroundTransparency = 1
    UI.shootButton.TextColor3 = Color3.new(1, 1, 1)
    UI.shootButton.Font = Enum.Font.Montserrat
    UI.shootButton.TextSize = 28.5
    UI.shootButton.Draggable = true
    UI.shootButton.Active = true
    UI.shootButton.ZIndex = 1
    UI.shootButton.Parent = UI.screenGui

    local corner = Instance.new("UICorner", UI.shootButton)
    corner.CornerRadius = UDim.new(0, 12)

    local stroke = Instance.new("UIStroke", UI.shootButton)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 120, 170)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ripple.BackgroundTransparency = 1
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
    ripple.ClipsDescendants = true
    ripple.ZIndex = 0
    ripple.Parent = UI.shootButton

    local rippleCorner = Instance.new("UICorner", ripple)
    rippleCorner.CornerRadius = UDim.new(1, 0)

    UI.shootButton.MouseButton1Down:Connect(function()
        ripple.BackgroundTransparency = 0.7
        ripple.Size = UDim2.new(0, 0, 0, 0)
        local tween = Services.TweenService:Create(ripple, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(1.5, 0, 1.5, 0),
            BackgroundTransparency = 1
        })
        tween:Play()
    end)

    UI.shootButton.MouseButton1Click:Connect(function()
        _G.ClickSound:Play()
        Utility.tryAutoShoot()
    end)
end

local FlingUtility = {}

function FlingUtility.SkidFling(TargetPlayer)
    local Character = LocalPlayer.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart
    if not (Humanoid and RootPart) then return end
    local TChar = TargetPlayer and TargetPlayer.Character
    if not TChar then return end
    local THumanoid = TChar:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TChar:FindFirstChild("Head")
    local Accessory = TChar:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")
    if RootPart:FindFirstChild("EpixVel") then return end
    State.StoredCFrame = RootPart.CFrame
    local Camera = workspace.CurrentCamera
    Camera.CameraSubject = THead or Handle or THumanoid or RootPart
    if not Character.PrimaryPart then
    Character.PrimaryPart = RootPart
end
local function FPos(BasePart, Pos, Ang)
    if RootPart then
        local cf = CFrame.new(BasePart.Position) * Pos * Ang
        RootPart.CFrame = cf

        if not Character.PrimaryPart then
            Character.PrimaryPart = RootPart
        end

        Character:SetPrimaryPartCFrame(cf)
        RootPart.Velocity = Vector3.new(9e7, 9e8, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end
end
    local function SFBasePart(BasePart)
        local Time = tick()
        local Angle = 0
        repeat
            if RootPart and THumanoid and TChar:IsDescendantOf(game) then
                local moveDir = THumanoid.MoveDirection
                local speed = BasePart.Velocity.Magnitude
                Angle += 100
                if speed < 50 then
                    local dirs = {
                        CFrame.new(0, 1.5, 0),
                        CFrame.new(0, -1.5, 0),
                        CFrame.new(2.25, 1.5, -2.25),
                        CFrame.new(-2.25, -1.5, 2.25)
                    }
                    for _, dir in ipairs(dirs) do
                        FPos(BasePart, dir + moveDir * speed / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    end
                else
                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()
                end
            else
                break
            end
        until BasePart.Velocity.Magnitude > 125 or tick() > Time + 2 or not BasePart:IsDescendantOf(game)
    end
    workspace.FallenPartsDestroyHeight = math.huge
    local BV = Instance.new("BodyVelocity")
    BV.Name = "EpixVel"
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BV.Parent = RootPart
    local BG = Instance.new("BodyGyro")
    BG.P = 1e6
    BG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    BG.CFrame = RootPart.CFrame
    BG.Parent = RootPart
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    local flingPart = TRootPart or THead or Handle
    if flingPart then
        SFBasePart(flingPart)
    else
        warn("No valid part to fling.")
    end
    BV:Destroy()
    BG:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    RootPart.Velocity = Vector3.zero
    RootPart.RotVelocity = Vector3.zero
    Humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    task.wait()
    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    Utility.teleportBack()
    if State.StoredCFrame then
        Camera.CameraSubject = Humanoid
        local resetCF = State.StoredCFrame * CFrame.new(0, 0.5, 0)
        RootPart.CFrame = resetCF
        Character:SetPrimaryPartCFrame(resetCF)
        State.StoredCFrame = nil
    end
    workspace.FallenPartsDestroyHeight = -500
end

function FlingUtility.SkidFlingByName(name)
    local target = Services.Players:FindFirstChild(name)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        FlingUtility.SkidFling(target)
    end
end
function FlingUtility.SkidFlingRole(role)
    for name, info in pairs(State.roleTable or {}) do
        if info.Role == role then
            local plr = Services.Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                if plr.Character.HumanoidRootPart.Velocity.Magnitude < 125 then
                    FlingUtility.SkidFling(plr)
                end
                break
            end
        end
    end
end

function FlingUtility.SkidFlingAll()
    for _, plr in ipairs(Services.Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            if plr.Character.HumanoidRootPart.Velocity.Magnitude < 150 then
                FlingUtility.SkidFling(plr)
                task.wait(0.010)
            end
        end
    end
end

function FlingUtility.SmartMatchPlayer(input)
    local query = input:lower()
    local bestMatch = nil

    for _, plr in ipairs(Services.Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local uname = plr.Name:lower()
            local dname = plr.DisplayName:lower()

            if uname == query or dname == query then
                return plr
            elseif uname:sub(1, #query) == query or dname:sub(1, #query) == query then
                bestMatch = plr
            elseif uname:find(query) or dname:find(query) then
                bestMatch = bestMatch or plr
            end
        end
    end

    return bestMatch
end

for _, desc in ipairs(Services.Workspace:GetDescendants()) do
    if desc:IsA("BasePart") and desc.Name == "GunDrop" then
        GameObjects.gunDrop = desc
        break
    end
end

Services.Workspace.DescendantAdded:Connect(function(desc)
    if desc:IsA("BasePart") and desc.Name == "GunDrop" then
        GameObjects.gunDrop = desc
    end
end)

Services.Workspace.DescendantAdded:Connect(function(desc)
    if not State.GunOutlineEnabled then return end
    if desc.Name == "GunDrop" and desc:IsA("BasePart") and not State.cachedGuns[desc] then
        State.cachedGuns[desc] = true
        Utility.createGunOutline(desc)
    end
end)

Services.Workspace.DescendantRemoving:Connect(function(desc)
    if desc.Name == "GunDrop" and desc:IsA("BasePart") then
        State.cachedGuns[desc] = nil
        Utility.removeGunOutline(desc)
    end
end)

for _, player in ipairs(Services.Players:GetPlayers()) do
    if player ~= LocalPlayer then
        Utility.setupPlayer(player)
    end
end

Services.Players.PlayerAdded:Connect(Utility.setupPlayer)
Services.Players.PlayerRemoving:Connect(Utility.removeESP)

local toggle = false
if Connections.espUpdateConnection then
    Connections.espUpdateConnection:Disconnect()
end

Connections.espUpdateConnection = Services.RunService.Heartbeat:Connect(function()
    toggle = not toggle
    if not toggle then return end

    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character then continue end
        local role = Utility.getRole(player)

        -- Outline
        if State.OutlineESPEnabled[role] then
            if not GameObjects.OutlineInstances[player] then
                Utility.createOutline(player)
            else
                GameObjects.OutlineInstances[player].OutlineColor = roleColors[role]
            end
        elseif GameObjects.OutlineInstances[player] then
            GameObjects.OutlineInstances[player]:Destroy()
            GameObjects.OutlineInstances[player] = nil
        end

        -- Label
        if State.LabelESPEnabled[role] then
            if not GameObjects.LabelInstances[player] then
                Utility.createLabel(player)
            else
                local label = GameObjects.LabelInstances[player]:FindFirstChild("Text")
                local head = player.Character:FindFirstChild("Head")
                if label and head and hrp then
                    local dist = (head.Position - hrp.Position).Magnitude
                    label.Text = string.format("%s [%.0f]", player.Name, dist)
                    label.TextColor3 = roleColors[role]
                end
            end
        elseif GameObjects.LabelInstances[player] then
            GameObjects.LabelInstances[player]:Destroy()
            GameObjects.LabelInstances[player] = nil
        end

        -- Tracer
        local enabled = State.TraceESPEnabled.All or State.TraceESPEnabled[role]
        if enabled then
            if not GameObjects.TracerLines[player] then
                Utility.createTracer(player)
            end

            local tracer = GameObjects.TracerLines[player]
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") and Camera then
                local pos, onScreen = Camera:WorldToViewportPoint(char.HumanoidRootPart.Position)
                if onScreen then
                    tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    tracer.To = Vector2.new(pos.X, pos.Y)
                    tracer.Color = roleColors[role] or roleColors.Unknown
                    tracer.Visible = true
                else
                    tracer.Visible = false
                end
            else
                tracer.Visible = false
            end
        elseif GameObjects.TracerLines[player] then
            GameObjects.TracerLines[player]:Remove()
            GameObjects.TracerLines[player] = nil
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Utility.StartAntiFling()
end)

if LocalPlayer.Character then
    Utility.StartAntiFling()
end

if LocalPlayer.Character then
    Handlers.setupCharacter(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(Handlers.setupCharacter)

task.spawn(function()
    while true do
        local success, result = pcall(function()
            return GetPlayerData:InvokeServer()
        end)
        if success and typeof(result) == "table" then
            State.roleTable = result
        end
        task.wait(1)
    end
end)

task.spawn(function()
    while true do
        if GetPlayerData then
            local success, data = pcall(function()
                return GetPlayerData:InvokeServer()
            end)
            State.cachedTargetPart = success and data and Utility.getMurdererTargetPart(data) or nil
        end
        task.wait(0.1)
    end
end)

task.spawn(function()
    while true do
        local role = "Unknown"
        while role == "Unknown" do
            local success, data = pcall(function()
                return Services.ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            end)

            if success and typeof(data) == "table" then
                local info = data[LocalPlayer.Name]
                if typeof(info) == "table" and info.Role then
                    role = info.Role
                elseif typeof(info) == "string" then
                    role = info
                end
            end

            task.wait(1)
        end

        local chance = 0
        pcall(function()
            chance = Services.ReplicatedStorage:FindFirstChild("Remotes", true).Extras.GetChance:InvokeServer()
        end)

        if State.showRolePrediction or State.showMurdererChance then
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "RoleDisplayGui"
            screenGui.IgnoreGuiInset = true
            screenGui.ResetOnSpawn = false
            screenGui.Parent = gethui and gethui() or LocalPlayer:WaitForChild("PlayerGui")

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0, 320, 0, 50)
            label.Position = UDim2.new(0.5, -160, 0.15, 0)
            label.BackgroundTransparency = 1
            label.TextStrokeTransparency = 0.5
            label.Font = Enum.Font.Montserrat
            label.TextSize = 20
            label.TextColor3 = roleColors[role] or Color3.new(1, 1, 1)

            local lines = {}
            if State.showRolePrediction then
                table.insert(lines, "Your Role: " .. tostring(role))
            end
            if State.showMurdererChance then
                table.insert(lines, "Murderer chance = " .. math.floor(chance + 0.5) .. "%")
            end
            label.Text = table.concat(lines, "\n")
            label.Parent = screenGui

            task.delay(5, function()
                if screenGui then screenGui:Destroy() end
            end)
        end

        repeat
            task.wait(1)
            local success, data = pcall(function()
                return Services.ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            end)
            local stillExists = success and typeof(data) == "table" and data[LocalPlayer.Name]
        until not stillExists
    end
end)
Utility.bringAndStab = function(player)
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local char = player.Character
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local localChar = LocalPlayer.Character
    if not localChar then return end
    local localHRP = localChar:FindFirstChild("HumanoidRootPart")
    if not localHRP then return end

    if not Utility.ensureKnifeEquipped() then return end

    local originalCFrame = hrp.CFrame
    local originalPlatformStand = humanoid.PlatformStand

    hrp.CFrame = localHRP.CFrame * CFrame.new(0, 0, -1)
    humanoid.PlatformStand = true

    local conn
    conn = Services.RunService.RenderStepped:Connect(function()
        if player.Character and player.Character.PrimaryPart then
            player.Character.PrimaryPart.CFrame = localHRP.CFrame * CFrame.new(0, 0, -1)
        end
    end)

    task.wait()

    local knife = localChar:FindFirstChild("Knife")
    if knife and knife:FindFirstChild("Stab") then
        knife.Stab:FireServer("Slash")
    end

    task.wait(0.01)

    conn:Disconnect()
    if hrp then
        hrp.CFrame = originalCFrame
    end
    if humanoid then
        humanoid.PlatformStand = originalPlatformStand
    end
end

Utility.stab = function()
    local knife = Services.Players.LocalPlayer.Character:FindFirstChild("Knife")
    if knife and knife:FindFirstChild("Stab") then
        local args = { "Slash" }
        knife.Stab:FireServer(unpack(args))
    end
end

Utility.bringAndStab = function(player)
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local char = player.Character
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local localChar = LocalPlayer.Character
    if not localChar then return end
    local localHRP = localChar:FindFirstChild("HumanoidRootPart")
    if not localHRP then return end

    if not Utility.ensureKnifeEquipped() then return end

    local originalCFrame = hrp.CFrame
    local originalPlatformStand = humanoid.PlatformStand

    hrp.CFrame = localHRP.CFrame * CFrame.new(0, 0, -1)
    humanoid.PlatformStand = true

    local conn
    conn = Services.RunService.RenderStepped:Connect(function()
        if player.Character and player.Character.PrimaryPart then
            player.Character.PrimaryPart.CFrame = localHRP.CFrame * CFrame.new(0, 0, -1)
        end
    end)

    task.wait()

    local knife = localChar:FindFirstChild("Knife")
    if knife and knife:FindFirstChild("Stab") then
        knife.Stab:FireServer("Slash")
    end

    task.wait(1.3)

    conn:Disconnect()
    if hrp then
        hrp.CFrame = originalCFrame
    end
    if humanoid then
        humanoid.PlatformStand = originalPlatformStand
    end
end

Utility.findNearestPlayer = function()
    local closest = nil
    local shortest = math.huge
    local myHRP = Services.Players.LocalPlayer.Character and Services.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHRP then return end
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= Services.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (player.Character.HumanoidRootPart.Position - myHRP.Position).Magnitude
            if dist < shortest then
                shortest = dist
                closest = player
            end
        end
    end
    return closest
end

Utility.findPlayerByPartial = function(input)
    input = input:lower()
    for _, player in pairs(Services.Players:GetPlayers()) do
        if player.Name:lower():sub(1, #input) == input then
            return player
        end
    end
end

Handlers.CheckForGun = function(callback)
    for _, player in pairs(Services.Players:GetPlayers()) do
        local backpack = player:FindFirstChild("Backpack")
        local character = player.Character
        if (backpack and backpack:FindFirstChild("Gun")) or (character and character:FindFirstChild("Gun")) then
            return callback(player)
        end
    end
end
Services.RunService.Stepped:Connect(Utility.updateFlatPose)

Services.ReplicatedStorage.Remotes.Gameplay.RoundStart.OnClientEvent:Connect(Utility.onRoundStart)
Services.ReplicatedStorage.Remotes.Gameplay.RoundEndFade.OnClientEvent:Connect(Utility.onRoundEnd)
Services.ReplicatedStorage.Remotes.Gameplay.CoinCollected.OnClientEvent:Connect(Utility.onCoinCollected)

Services.RunService.RenderStepped:Connect(function()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if State.walkSpeedEnabled then
            humanoid.WalkSpeed = State.walkSpeedValue
        end
        if State.jumpPowerEnabled then
            humanoid.JumpPower = State.jumpPowerValue
        end
    end
end)

local Window = Rayfield:CreateWindow({
    Name = "Makal Hub | MM2",
    Icon = 0,
    LoadingTitle = "Please Wait.",
    LoadingSubtitle = "by Xynnn Him Self! :3",
    Theme = "DarkBlue",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "Big Hub"
    },
    Discord = {
        Enabled = true,
        Invite = "getfrost",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "Untitled",
        Subtitle = "Key System",
        Note = "No method of obtaining the key is provided",
        FileName = "Key",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"Hello"}
    }
})

local Tab = Window:CreateTab("Combat", 4483362458)
local Tab1 = Window:CreateTab("Visuals", 4483362458)
local Tab2 = Window:CreateTab("Teleports", 4483362458)
local Tab3 = Window:CreateTab("Miscellaneous", 4483362458)
local Tab4 = Window:CreateTab("LocalPlayer", 4483362458)
local Tab6 = Window:CreateTab("Troll", 4483362458)
local Tab7 = Window:CreateTab("Farm", 4483362458)
local Tab5 = Window:CreateTab("Credits", 4483362458)

local Section = Tab:CreateSection("Sheriff")

Tab:CreateButton({
    Name = "Grab Gun",
    Callback = Utility.grabGunOnce,
})

Tab:CreateButton({
    Name = "Shoot Murderer",
    Callback = Handlers.handleShootMurderer
})

Tab:CreateToggle({
    Name = "Grab Gun Button",
    CurrentValue = false,
    Flag = "GrabGunToggle",
    Callback = function(state)
        if state then
            UICreator.createGrabGunButton()
        else
            if UI.grabGunButton then
                UI.grabGunButton:Destroy()
                UI.grabGunButton = nil
            end
        end
    end
})

Tab:CreateToggle({
    Name = "Shoot Murderer Button",
    CurrentValue = false,
    Callback = function(state)
        if state then
            UICreator.createShootButton()
        elseif UI.screenGui then
            UI.screenGui:Destroy()
            UI.screenGui, UI.shootButton = nil, nil
        end
    end,
})
Tab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = false,
    Callback = function(Value)
        State.WallCheck = Value
    end,
})
Tab:CreateButton({
    Name = "Kill Murderer",
    Callback = Handlers.handleShootMurdererTeleportBack
})
Tab:CreateToggle({
    Name = "Kill Murderer Button",
    CurrentValue = false,
    Callback = function(state)
        if state then
            UICreator.createShootback()
        else
            UICreator.destroyShootbackButton()
        end
    end,
})
local Section = Tab:CreateSection("Murderer")
Tab:CreateButton({
	Name = "Kill Nearest",
	Callback = function()
		local target = Utility.findNearestPlayer()
		if target then
			Utility.bringAndStab(target)
		end
	end
})

Tab:CreateButton({
	Name = "Kill Everyone",
	Callback = function()
		for _, player in pairs(Services.Players:GetPlayers()) do
			if player ~= Services.Players.LocalPlayer then
				Utility.bringAndStab(player)
task.wait(0.01)
			end
		end
	end
})

Tab:CreateButton({
	Name = "Kill Sheriff",
	Callback = function()
		Handlers.CheckForGun(function(player)
			Utility.bringAndStab(player)
		end)
	end
})

Tab:CreateInput({
    Name = "Kill by Name",
    PlaceholderText = "Type partial name...",
    RemoveTextAfterFocusLost = true,
    Callback = function(text)
        local target = Utility.findPlayerByPartial(text)
        if target then
            Utility.bringAndStab(target)
        end
    end
})
Tab:CreateButton({
    Name = "Silent Throw Nearest",
    Callback = function()
        if not Utility.ensureKnifeEquipped() then return end

        local knife = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Knife")
        local throw = knife and knife:FindFirstChild("Throw")
        local handle = knife and knife:FindFirstChild("Handle")
        if not throw or not handle then return end

        local target = Utility.findNearestPlayer()
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local predicted = Utility.getPredictedPos(target.Character.HumanoidRootPart)
            throw:FireServer(CFrame.new(predicted), handle.Position)
        end
    end
})
local Toggle = Tab1:CreateToggle({
    Name = "Gun Outline ESP",
    CurrentValue = false,
    Flag = "GunOutlineToggle",
    Callback = function(Value)
        Utility.ToggleGunOutline(Value)
    end,
})

local Section = Tab1:CreateSection("Outline")
Tab1:CreateToggle({
    Name = "All Outline ESP",
    CurrentValue = false,
    Callback = Utility.setAllOutlines
})

Tab1:CreateToggle({
    Name = "Outline: Murderer",
    CurrentValue = false,
    Callback = function(val) Utility.setOutline("Murderer", val) end
})

Tab1:CreateToggle({
    Name = "Outline: Sheriff + Hero",
    CurrentValue = false,
    Callback = function(val)
        Utility.setOutline("Sheriff", val)
        Utility.setOutline("Hero", val)
    end
})

Tab1:CreateToggle({
    Name = "Outline: Innocent",
    CurrentValue = false,
    Callback = function(val) Utility.setOutline("Innocent", val) end
})

local Section = Tab1:CreateSection("ESP")
Tab1:CreateToggle({
    Name = "All ESP",
    CurrentValue = false,
    Callback = Utility.setAllLabels
})

Tab1:CreateToggle({
    Name = "ESP: Murderer",
    CurrentValue = false,
    Callback = function(val) Utility.setLabel("Murderer", val) end
})

Tab1:CreateToggle({
    Name = "ESP: Sheriff + Hero",
    CurrentValue = false,
    Callback = function(val)
        Utility.setLabel("Sheriff", val)
        Utility.setLabel("Hero", val)
    end
})

Tab1:CreateToggle({
    Name = "ESP: Innocent",
    CurrentValue = false,
    Callback = function(val) Utility.setLabel("Innocent", val) end
})

local Section = Tab1:CreateSection("Trace")
Tab1:CreateToggle({
    Name = "Trace All",
    CurrentValue = false,
    Callback = Utility.setAllTracers
})

Tab1:CreateToggle({
    Name = "Trace Murderer",
    CurrentValue = false,
    Callback = function(val) Utility.setTrace("Murderer", val) end
})

Tab1:CreateToggle({
    Name = "Trace Sheriff",
    CurrentValue = false,
    Callback = function(val) Utility.setTrace("Sheriff", val) end
})

Tab1:CreateToggle({
    Name = "Trace Innocent",
    CurrentValue = false,
    Callback = function(val) Utility.setTrace("Innocent", val) end
})

local Button = Tab2:CreateButton({
   Name = "Teleport to Lobby",
   Callback = function()
      Utility.teleportToLobby()
   end
})

local Button = Tab2:CreateButton({
   Name = "Teleport to Map",
   Callback = Utility.teleportToMapSpawn
})

Tab2:CreateButton({
    Name = "Teleport to Sheriff/Hero",
    Callback = function()
        Handlers.CheckForGun(Handlers.onPlayerHasGun)
    end
})

Tab2:CreateButton({
    Name = "Teleport to Murderer",
    Callback = function()
        Handlers.CheckForKnife(Handlers.onPlayerHasKnife)
    end
})

local Input = Tab2:CreateInput({
    Name = "Teleport to Player",
    CurrentValue = "",
    PlaceholderText = "Enter player name...",
    RemoveTextAfterFocusLost = false,
    Flag = "TeleportInput",
    Callback = function(Text)
        local lowerText = Text:lower()

        local closestPlayer = nil
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local playerName = player.Name:lower()
                if playerName:sub(1, #lowerText) == lowerText then
                    closestPlayer = player
                    break
                end
            end
         end
        if closestPlayer then
            Utility.teleportToPlayer(closestPlayer)
        else
            warn("No matching player found!")
        end
    end,
})

Tab3:CreateToggle({
    Name = "Auto Avoid Murderer",
    CurrentValue = false,
    Callback = function(value)
        State.AutoAvoidEnabled = value
    end,
})

local Section = Tab3:CreateSection("Gameplay")
local Toggle = Tab3:CreateToggle({
    Name = "Enable Gun Drop Notification",
    CurrentValue = false,
    Flag = "GunDropNotification",
    Callback = function(state)
        if state then
            Utility.startGunDropDetection()
        end
    end
})

Tab3:CreateToggle({
    Name = "Auto Grab Gun",
    Default = false,
    Callback = function(state)
        State.isGrabGunActive = state
        if state then
            Utility.startAutoGrabGun()
        end
    end
})

Tab3:CreateToggle({
    Name = "Round Timer",
    CurrentValue = false,
    Callback = Utility.toggleRoundTimerESP
})

Tab3:CreateToggle({
    Name = "Show Role Prediction",
    CurrentValue = false,
    Callback = function(v) State.showRolePrediction = v end,
})

Tab3:CreateToggle({
    Name = "Show Murderer Chance",
    CurrentValue = false,
    Callback = function(v) State.showMurdererChance = v end,
})

local Section = Tab3:CreateSection("Roles")
Tab3:CreateButton({
    Name = "Notify Sheriff & Murderer",
    Callback = function()
        Utility.notifyPlayers()
    end,
})

Tab3:CreateButton({
    Name = "Blurt Murderer",
    Callback = Utility.blurtOnlyMurderer
})

Tab3:CreateButton({
    Name = "Blurt Sheriff",
    Callback = Utility.blurtOnlySheriff
})

Tab3:CreateButton({
    Name = "Blurt Murderer And Sheriff",
    Callback = Utility.blurtBothRoles
})

local Section = Tab3:CreateSection("Prank Bomb")
Tab3:CreateToggle({
    Name = "Prank Bomb Bindable Button",
    CurrentValue = false,
    Flag = "FakeBombToggle",
    Callback = function(state)
        if state then
            UICreator.createFakeBombButton()
        else
            UICreator.destroyFakeBombButton()
        end
    end
})
Tab3:CreateToggle({
    Name = "Auto Teleport To Prank Bomb",
    Default = false,
    Callback = function(state)
        State.BombTeleportEnabled = state

        if State.BombTeleportEnabled then
            Connections.BombConnection = Services.RunService.Heartbeat:Connect(function()
                for _, obj in ipairs(Services.Workspace:GetChildren()) do
                    if obj:IsA("Part") and obj.Name == "Handle" then
                        local creator = obj:FindFirstChild("creator")
                        if creator and creator.Value == LocalPlayer then
                            Utility.HandleFound(obj)
                        end
                    end
                end
            end)
        else
            if Connections.BombConnection then
                Connections.BombConnection:Disconnect()
                Connections.BombConnection = nil
            end
            for part, conn in pairs(GameObjects.ConnectedHandles) do
                if conn then
                    conn:Disconnect()
                end
            end
            GameObjects.ConnectedHandles = {}
        end
    end
})

local Section = Tab3:CreateSection("Speed Glitch")

Tab3:CreateToggle({
    Name = "Speed Glitch Bindable Button",
    CurrentValue = false,
    Flag = "SpeedGlitchToggle",
    Callback = function(state)
        if state then
            UICreator.createSpeedButton()
        else
            if UI.speedButton then
                UI.speedButton:Destroy()
                UI.speedButton = nil
            end
        end
    end
})

local Section = Tab4:CreateSection("Noclip")
Tab4:CreateToggle({
    Name = "Noclip Bindable Button",
    Default = false,
    Callback = function(state)
        if state then
            UICreator.createNoclipButton()
        else
            if UI.noclipButton then
                UI.noclipButton:Destroy()
                UI.noclipButton = nil
            end
            Utility.setNoclip(false)
        end
    end
})

Tab4:CreateToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(state)
        Utility.setNoclip(state)
    end
})

Tab4:CreateToggle({
    Name = "Anti Void",
    Default = false,
    Callback = function(state)
        if state then
            Services.HeartbeatConnection = Services.RunService.Heartbeat:Connect(function()
                pcall(function()
                    local char = LocalPlayer.Character
                    if not char then return end
                    local root = char:FindFirstChild("HumanoidRootPart")
                    if not root then return end
                    if root.Position.Y <= -465 then
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                    end
                end)
            end)
        else
            if Services.HeartbeatConnection then
                Services.HeartbeatConnection:Disconnect()
                Services.HeartbeatConnection = nil
            end
        end
    end
})
Tab4:CreateToggle({
    Name = "Anti Fling",
    Default = false,
    Callback = function(state)
        if state then
            Utility.enableFlingVelocityBlock()
        else
            Utility.disableFlingVelocityBlock()
        end
    end
})

Tab4:CreateToggle({
   Name = "Enable WalkSpeed",
   CurrentValue = false,
   Callback = function(on)
      State.walkSpeedEnabled = on
      if not on then
         local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
         if humanoid then
            humanoid.WalkSpeed = Config.defaultWalkSpeed
         end
      end
   end,
})

Tab4:CreateSlider({
   Name = "WalkSpeed",
   Range = {16, 300},
   Increment = 1,
   CurrentValue = Config.defaultWalkSpeed,
   Callback = function(value)
      State.walkSpeedValue = value
   end,
})

Tab4:CreateToggle({
   Name = "Enable JumpPower",
   CurrentValue = false,
   Callback = function(on)
      State.jumpPowerEnabled = on
      if not on then
         local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
         if humanoid then
            humanoid.JumpPower = Config.defaultJumpPower
         end
      end
   end,
})

Tab4:CreateSlider({
   Name = "JumpPower",
   Range = {50, 300},
   Increment = 5,
   CurrentValue = Config.defaultJumpPower,
   Callback = function(value)
      State.jumpPowerValue = value
   end,
})
Tab6:CreateButton({
    Name = "Steal Gun!",
    Callback = function()
        local gunHolder
        Handlers.CheckForGun(function(player)
            gunHolder = player
        end)
        if not gunHolder then return end
        FlingUtility.SkidFling(gunHolder)
        local gunDrop
        repeat
            gunDrop = workspace:FindFirstChild("GunDrop", true)
            Services.RunService.Heartbeat:Wait()
        until gunDrop
        Utility.grabGunOnce()
    end
})
Tab6:CreateButton({
    Name = "Fling Sheriff",
    Callback = function()
        FlingUtility.SkidFlingRole("Sheriff")
    end
})

Tab6:CreateButton({
    Name = "Fling Hero",
    Callback = function()
        FlingUtility.SkidFlingRole("Hero")
    end
})

Tab6:CreateButton({
    Name = "Fling Murderer",
    Callback = function()
        FlingUtility.SkidFlingRole("Murderer")
    end
})

Tab6:CreateInput({
    Name = "Fling Player by Name",
    PlaceholderText = "Enter Player Name",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        local target = FlingUtility.SmartMatchPlayer(text)
        if target then
            FlingUtility.SkidFling(target)
        end
    end
})

Tab6:CreateButton({
    Name = "Fling Everyone",
    Callback = function()
        FlingUtility.SkidFlingAll()
    end
})

Tab7:CreateToggle({
    Name = "Auto Farm Coins",
    CurrentValue = false,
    Callback = function(state)
        State.farmingEnabled = state
        if state then
            Utility.startFarmLogic()
        else
            Utility.stopFarmLogic()
        end
    end
})
Tab7:CreateToggle({
	Name = "Reset if Innocent",
	CurrentValue = false,
	Callback = function(v) State.ToggleAutoReset = v end,
})

Tab7:CreateToggle({
	Name = "Shoot Murderer if Sheriff/Hero",
	CurrentValue = false,
	Callback = function(v) State.ToggleKillMurderer = v end,
})

Tab7:CreateToggle({
	Name = "Kill All if Murderer",
	CurrentValue = false,
	Callback = function(v) State.ToggleKillAll = v end,
})
local Paragraph = Tab5:CreateParagraph({Title = "Made By:", Content = "Xynnn. Join Discord For Updates!"})

local Button = Tab5:CreateButton({
   Name = "Copy Discord Link Here!",
   Callback = function()
    setclipboard("https://discord.gg/8MYHkaJqWt")
   end,
})
--Loops if needed
task.spawn(function()
    while true do
        task.wait(0.5)

        if State.AutoAvoidEnabled and LocalPlayer.Character then
            local myData = State.roleTable[LocalPlayer.Name]
            if myData and myData.Role == "Murderer" then
                continue
            end

            local murderer = Utility.getMurderer()
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if murderer and murderer.Character and myHRP then
                local mHRP = murderer.Character:FindFirstChild("HumanoidRootPart")
                if mHRP then
                    local distanceToMurderer = (mHRP.Position - myHRP.Position).Magnitude

                    if not State.Avoiding then
                        if distanceToMurderer < 20 then
                            State.StoredCFrame = myHRP.CFrame
                            Utility.teleportToLobby()
                            State.Avoiding = true
                        end
                    elseif State.Avoiding then
                        local storedPos = State.StoredCFrame and State.StoredCFrame.Position
                        if storedPos then
                            local distanceToOriginal = (mHRP.Position - storedPos).Magnitude
                            if distanceToOriginal > 30 then
                                Utility.teleportBack()
                                State.Avoiding = false
                            end
                        else
                            Utility.teleportBack()
                            State.Avoiding = false
                        end
                    end
                end
            end
        end
    end
end
end)

Services.RunService.Heartbeat:Connect(function()
    if not State.autoThrowEnabled then return end

    -- getKnifeTool returns knife, throw remote, and handle
    local knife, throw, handle = Utility.getKnifeTool()
    if not throw or not handle then return end

    local character = LocalPlayer.Character
    local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end

    -- Check if ThrowCharge animation is playing
    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
        if track.Name == "ThrowCharge" then
            -- Find nearest player
            local target = Utility.findNearestPlayer()
            if target and target.Character then
                local hrp = target.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    -- Predict position (you should have this in Utility)
                    local predicted = Utility.getPredictedPos(hrp)
                    -- Fire server with CFrame.new(predicted), handle.Position as args
                    throw:FireServer(CFrame.new(predicted), handle.Position)
                end
            end
            break -- no need to continue checking other animations
        end
    end
end